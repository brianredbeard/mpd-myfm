#!/usr/bin/env python

import getopt
import mpd
import os
import random
import socket
import sys
import time
import urllib

def main(): # {{{1

	# Parse the command-line options.
	try:
		options, arguments = getopt.getopt(sys.argv[1:], 'H:p:P:r:u:s:R:h', \
				['host=', 'port=', 'pass=', 'reconnect=', 'update=', 'songs=', 'repeat=', 'help'])
	except getopt.GetoptError, err:
		print str(err)
		usage()
		sys.exit(1)

	# Define command-line option defaults.
	hostname = '127.0.0.1'
	portnr = 6600
	passwd = ''
	songsleft = 3
	updatetime = 5
	reconnecttime = 60
	repeatfactor = 20

	# Process the command-line options.
	for option, argument in options:
		if option in ('-H', '--host'): hostname = argument
		elif option in ('-p', '--port'): portnr = int(argument)
		elif option in ('-P', '--pass'): passwd = argument
		elif option in ('-s', '--songs'): songsleft = int(argument)
		elif option in ('-u', '--update'): updatetime = int(argument)
		elif option in ('-r', '--reconnect'): reconnecttime = int(argument)
		elif option in ('-R', '--repeat'): repeatfactor = int(argument)
		elif option in ('-h', '--help'):
			usage()
			sys.exit(0)
		else:
			print "Unhandled option `%s'" % (option)
			usage()
			sys.exit(1)
	
	client = mpd.MPDClient()
	artistsindb = {}
	genresindb = {}
	if not connect(client, hostname, portnr, passwd):
		print "Failed to connect to MPD server at `%s' on port `%i'" % (hostname, portnr)
		usage()
		sys.exit(1)
	else:
		while 1:
			try:
				if artistsindb == {}:
					for track in client.listallinfo():
						if 'artist' in track and track['artist'] != '':
							if not artistsindb.has_key(track['artist']):
								artistsindb[track['artist']] = []
							artistsindb[track['artist']].append(track['file'])
						if 'genre' in track:
							# track['genre'] can be a list of genres ..
							if type(track['genre']) == type(''): genres = [track['genre']]
							elif type(track['genre']) == type([]): genres = track['genre']
							else: genres = []
							# and may contain duplicates :\
							for genre in unique(genres):
								if genre != '':
									if not genresindb.has_key(genre): genresindb[genre] = []
									genresindb[genre].append(track['file'])
				if autoplayenabled(client.status(), songsleft):
					lastartist = client.playlistinfo()[-1]['artist']
					similarartists = getsimilarartists(lastartist)
					similartracks = findtracks(artistsindb, similarartists)
					similartracks = filterplaylisttracks(client, repeatfactor, similartracks)
					if len(similartracks) <= 3: # TODO Make treshold configurable?
						genre = client.playlistinfo()[-1]['genre']
						if genresindb.has_key(genre):
							similartracks.extend(genresindb[genre])
							similartracks = filterplaylisttracks(client, repeatfactor, similartracks)
					client.add(random.choice(similartracks))
				time.sleep(updatetime)
			except mpd.ConnectionError, msgconerrer:
				print 'Lost connection? (%s)' % msgconerrer
				time.sleep(reconnecttime)
				while not connect(client, hostname, portnr, passwd):
					pass
			except KeyboardInterrupt:
				client.disconnect()
				break

def unique(list): # {{{1
    result = []
    for item in list:
        if item not in result:
            result.append(item)
    return result

def filterplaylisttracks(client, repeatfactor, tracks): # {{{1
	trackstofilter = client.playlist()
	if len(trackstofilter) > repeatfactor:
		trackstofilter = trackstofilter[-repeatfactor]
	return [t for t in tracks if not t in trackstofilter]

def autoplayenabled(status, songsleft): # {{{1
	# The client doesn't do anything when MPD isn't playing.
	if not status.has_key('song'):
		return False
	# The client doesn't do anything when the user enables random and/or repeat.
	if int(status['random']) != 0 or int(status['repeat']) != 0:
		return False
	# The client doesn't do anything when the end of the play list hasn't been reached yet.
	if int(status['playlistlength']) > (int(status['song']) + songsleft):
		return False
	# Otherwise, the client is enabled.
	return True

def findtracks(artistsindb, artists): # {{{1
	""" Return a list of tracks in the MPD library from any of the given artists. """
	# TODO Fall back to tracks from same genre when no artists were given..
	tracks = []
	for artist in artists:
		if artistsindb.has_key(artist):
			tracks.extend(artistsindb[artist])
	return tracks

def getsimilarartists(artistname, limit=100): # {{{1
	"""
	Get a list of similar artists from Last.fm. The list is sorted by
	decreasing similarity.
	"""
	address = 'http://ws.audioscrobbler.com/2.0/artist/%s/similar.txt?limit=%i'
	handle = urllib.urlopen(address % (urllib.quote(artistname), limit))
	lines = handle.read().split("\n")
	handle.close()
	similarartists = []
	for record in [line.split(",") for line in lines]:
		if len(record) == 3:
			similarartists.append(record[2])
	if artistname in similarartists:
		similarartists.remove(artistname)
	return similarartists

def connect(client, hostname, portnr, passwd): # {{{1
	try:
		client.connect(host=hostname, port=portnr)
		if passwd != '': client.password(passwd)
		return True
	except socket.error:
		return False

def usage(): # {{{1
	scriptname = os.path.split(sys.argv[0])[1]
	print 'Usage: %s [OPTION]...' % (scriptname)
	print ''
	print '  -H, --host=HOSTNAME          host name of Music Player Daemon (localhost)'
	print '  -p, --port=PORTNR            port number on which MPD is listening (6600)'
	print '  -P, --pass=PASSWORD          password for connecting with MPD (empty)'
	print '  -r, --reconnect=SECONDS      seconds before client tries to reconnect (60)'
	print '  -u, --update=SECONDS         seconds between updates to the playlist (5)'
	print '  -s, --songs=COUNT            number of tracks before end of playlist to start adding songs (3)'
	print '  -h, --help                   show this help'

# }}}1

if __name__ == '__main__':
	main()
