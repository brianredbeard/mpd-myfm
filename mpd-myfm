#!/usr/bin/env python

#Import with statement from __future__ to support python 2.5
from __future__ import with_statement
import getopt
import htmlentitydefs
import mpd
import os
import random
import re
import socket
import sys
import time
import urllib
import traceback
import logging

CONFIG_FNAME = '~/.mpd-myfm'


def main(options):

	[logger, logfile] = createlog(options)
	if not not options['pidfile']:
		open(options['pidfile'],'w').write(str(os.getpid()))

	#import local modules, we do it here so that any errors get loged to the log file.
	import lastfm

	client = mpd.MPDClient()
	if not connect(client, options['hostname'], options['portnr'], options['passwd']):
		logmsg = "Failed to connect to MPD server at `%s' on port `%i'" % (options['hostname'], options['portnr'])
		logger.error(logmsg)
		usage()
		sys.exit(1)
	else:
		logger.info("Building the index of mpd's library")
		# Create an index from the user's library.
		index = LibraryIndex(client)
		# Get the user's loved & banned tracks from Last.fm?
		lovedtracks = []
		lovedartists = []
		bannedtracks = []
		if options['lastfmaccount'] != '':
			logger.info("Scraping last.fm for user's loved and banned tracks")
			for [artist, title] in lastfm.get_loved_tracks(options['lastfmaccount']):
				lovedtracks.append(createkey(artist, title))
				if artist != 'Various Artists' and not artist in lovedartists:
					lovedartists.append(createkey(artist))
			for [artist, title] in lastfm.get_banned_tracks(options['lastfmaccount']):
				bannedtracks.append(createkey(artist, title))
		logger.info("Done... Now starting main program loop.")
		if not not logfile:
			logfile.setLevel(logging.WARNING)
		while 1:
			try:
				if clientenabled(client.status(), options['songsleft'], logger):
					lasttrack = client.playlistinfo()[-1]
					similarartists_complex = [[a['similarity'], a['name']] for a in lastfm.get_similar_artists(lasttrack['artist'])]
					similarartists = []
					for artist in similarartists_complex:
						similarartists.append([artist[0], simplifyname(artist[1])])
					similarartists = demoteplayedartists(client, options['repeatfactor'], similarartists)
					if not options['albummode'] or not addalbum(client, index, similarartists, logger):
						addtrack(client, index, lasttrack, similarartists, options['repeatfactor'], lovedtracks, lovedartists, bannedtracks, logger)
				# Sleep for a while before trying to update again.
				sleep(options['updatetime'], logger)
			except (socket.error, mpd.ConnectionError), msgconerrer:
				# Let the user know what's going on.
				logmsg = 'Lost connection? (%s)' % msgconerrer
				logger.error(logmsg)
				# Try to close the connection in case it's still open.
				try: client.disconnect()
				except: pass
				# Sleep for a while before trying to reconnect.
				sleep(reconnecttime, logger)
				# Loop until we're connected to MPD again.
				while not connect(client, options['hostname'], options['portnr'], options['passwd']): pass
			except KeyboardInterrupt:
				# Disconnect and close client when interrupted.
				client.disconnect()
				break

def addtrack(client, index, lasttrack, similarartists, repeatfactor, lovedtracks, lovedartists, bannedtracks, logger): # {{{1
	similartracks = findsimilartracks(index, similarartists)
	similartracks = filterduplicates(client, repeatfactor, similartracks)
	removebannedtracks(bannedtracks, similartracks, logger)
	# TODO Make treshold configurable?
	if len(similartracks) <= 3 and lasttrack.get('genre', '') != '':
		logmsg = "Adding track based on same genre `%s'." % (lasttrack['genre'])
		logger.info(logmsg) 
		for track in index.findtracksingenre(lasttrack['genre']):
			similartracks.append([1, track])
		similartracks = filterduplicates(client, repeatfactor, similartracks)
		removebannedtracks(bannedtracks, similartracks, logger)
	if len(similartracks) >= 1:
		marklovedtracks(similartracks, lovedtracks, lovedartists, logger)
		tracktoadd = weightedrandomchoice(similartracks)
		client.add(tracktoadd['file'])
		logmsg = 'Added', tracktoadd['file'], 'to playlist.'
		logger.info(logmsg)
	else:
		logger.info('Failed to find similar track based on artist nor genre!')

def addalbum(client, index, similarartists, logger): # {{{1
	similaralbums = findsimilaralbums(index, similarartists)
	if len(similaralbums) <= 1:
		logger.info('Could not find any albums from similar artists, trying one lose track now.')
		logger.info('I will try an album again after that.')
		return False
	albumtoadd = weightedrandomchoice(similaralbums)
	trackstoload = index.findtracksinalbum(albumtoadd[0], albumtoadd[1])
	logmsg = "Adding %i tracks in album `%s' by artist `%s'" % ( \
			len(trackstoload), albumtoadd[1], albumtoadd[0])
	logger.info(logmsg) 
	for track in trackstoload:
		client.add(track['file'])
	return True

def findsimilaralbums(index, similarartists): # {{{1
	"""
	Return a list of albums in the Music Player Daemon library from any of the
	given artists. The numeric similarity associated with each artist is copied
	to all albums by that artist.
	"""
	albums = []
	for [similarity, artistname] in similarartists:
		for albumname in index.findalbumsbyartist(artistname):
				albums.append([similarity, [artistname, albumname]])
	return albums

def filterduplicates(client, repeatfactor, tracks): # {{{1
	"""
	Make sure a track is never repeated before a configurable number of other
	tracks (by default 20) has been played. The number of tracks can be set
	using the -s or --songs command-line argument.
	"""
	trackstofilter = client.playlist()
	if len(trackstofilter) < repeatfactor:
		repeatfactor = len(trackstofilter)
	trackstofilter = trackstofilter[-repeatfactor : -1]
	return [t for t in tracks if not t[1]['file'] in trackstofilter]

def demoteplayedartists(client, repeatfactor, similarartists): # {{{1
	"""
	Make it less likely that a song from an artist who is already in the last
	'repeatfactor' songs. We do not ban them because that would	make it very 
	hard to find similar songs after a wile.
	"""
	trackstofilter = client.playlistinfo()
	if len(trackstofilter) < repeatfactor:
		repeatfactor = len(trackstofilter)
	trackstofilter = trackstofilter[-repeatfactor : -1]
	artiststofilter = []
	for track in trackstofilter:
		artiststofilter.append(simplifyname(track['artist'].decode('utf-8')))
	demotedlist = []
	for artist in similarartists:
		if artist[1] in artiststofilter:
			artist[0] = artist[0] / 5
			demotedlist.append(artist)
		else:
			demotedlist.append(artist)
	return demotedlist

def clientenabled(status, songsleft, logger): # {{{1
	if int(status['playlistlength']) == 0:
		logger.debug("Doing nothing because play list is empty.")
		return False
	if int(status['random']) != 0:
		logger.debug("Doing nothing because random is enabled.")
		return False
	if int(status['repeat']) != 0:
		logger.debug("Doing nothing because repeat is enabled.")
		return False
	if status.has_key('song') and int(status['playlistlength']) > (int(status['song']) + songsleft) \
			or not status.has_key('song') and int(status['playlistlength']) >= songsleft:
		logger.debug("Doing nothing because the end of the playlist hasn't been reached.")
		return False
	return True

def findsimilartracks(index, similarartists): # {{{1
	"""
	Return a list of tracks in the Music Player Daemon library from any of the
	given artists. The numeric similarity associated with each artist is copied
	to all tracks by that artist.
	"""
	tracks = []
	for [similarity, artistname] in similarartists:
		for track in index.findtracksbyartist(artistname):
			tracks.append([similarity, track])
	return tracks

def marklovedtracks(similartracks, lovedtracks, lovedartists, logger): # {{{1
	"""
	Go through the similar tracks and increase the weights of favorite tracks
	and artists.
	"""
	nlovedtracks = 0
	nlovedartists = 0
	for record in similartracks:
		similarity, track = record
		if track.get('artist', '') != '' and track.get('title', '') != '' and \
				createkey(track['artist'], track['title']) in lovedtracks:
			record[0] += 25
			nlovedtracks += 1
		elif track.get('artist', '') != '' and \
				createkey(track['artist']) in lovedartists:
			record[0] += 10
			nlovedartists += 1
	if nlovedtracks > 0:
		logmsg = 'Marked', nlovedtracks, 'loved tracks from Last.fm'
		logger.debug(logmsg) 
	if nlovedartists > 0:
		logmsg = 'Marked', nlovedartists, 'tracks by loved artists from Last.fm'
		logger.debug(logmsg)

def removebannedtracks(bannedtracks, similartracks, logger): # {{{1
	"""
	Go through the similar tracks and remove all banned tracks.
	"""
	nbannedtracks = 0
	index = 0
	while index < len(similartracks):
		weight, track = similartracks[index]
		if track.get('artist', '') != '' and track.get('title', '') != '' and \
				createkey(track['artist'], track['title']) in bannedtracks:
			del similartracks[index]
			nbannedtracks += 1
		else:
			index += 1
	if nbannedtracks > 0:
		logmsg = 'Ignored', nbannedtracks, 'banned track(s) from Last.fm'
		logger.debug(logmsg) 


# Miscellaneous functions. {{{1

def createkey(*args): # {{{2
	"""
	Simplify a list of strings (one or more of artist name, album name, track
	title) into a single string using the simplifyname() function.
	"""
	return '-'.join(map(simplifyname, args))

def simplifyname(string): # {{{2
	"""
	Simplify artist names for fuzzy matching.
	"""
	global _cachednames
	if _cachednames.has_key(string):
		return _cachednames[string]
	else:
		result = string.lower()
		result = re.sub('^the\s+', '', result)
		result = re.sub(',\s+the$', '', result)
		result = re.sub('[^a-z0-9 -]', '', result)
		result = re.sub('\s+', ' ', result)
		_cachednames[string] = result
		return result
 
_cachednames = {}

def simplecompare(left, right): # {{{2
	"""
	Compare two strings using the simplifyname() function and return True when
	they are equal.
	"""
	return simplifyname(left) == simplifyname(right)

def weightedrandomchoice(items): # {{{2
	"""
	Pick a weighted random value from a list of lists, where each list contains
	a numeric weight followed by any type of associated value.
	"""
	total = 0
	for item in items:
		total += item[0]
	threshold = random.uniform(0.6, 1) * total 
	items.sort()
	for item in items:
		threshold -= item[0]
		if threshold <= 0:
			return item[1]

def sleep(seconds, logger): # {{{2
	logmsg = 'Sleeping for', seconds, 'seconds'
	logger.debug(logmsg) 
	time.sleep(seconds)

def unique(list): # {{{2
    result = []
    for item in list:
        if item not in result:
            result.append(item)
    return result


def createlog(options): # {{{2
	if not options['logfile']:
		logfile = False
	logger = logging.getLogger("mpd-myfm")
	logger.setLevel(logging.DEBUG)
	if not not options['logfile']:
		logfile = logging.FileHandler(options['logfile'], mode='a', encoding='utf-8')
		logfile.setLevel(logging.NOTSET)
		logfile.setFormatter(logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s'))
		logger.addHandler(logfile)
	if not options['daemonize']:
		console = logging.StreamHandler()
		if options['verbosity'] == 0:
			console.setLevel(logging.WARNING)
		if options['verbosity'] == 1:
			console.setLevel(logging.INFO)
		if options['verbosity'] == 2:
			console.setLevel(logging.DEBUG)
		if options['verbosity'] >= 3:
			console.setLevel(logging.NOTSET)
		console.setFormatter(logging.Formatter('%(name)s: %(levelname)s %(message)s'))
		logger.addHandler(console)
	logger.info('Started mpd-myfm client')
	return [logger, logfile]

def connect(client, hostname, portnr, passwd): # {{{2
	try:
		client.connect(host=hostname, port=portnr)
		if passwd != '': client.password(passwd)
		return True
	except socket.error:
		return False

def doargs(args): # {{{2
	try:
		opts, args = getopt.getopt(args, 'H:p:P:r:u:s:R:l:AL:DF:vh', \
				['host=', 'port=', 'pass=', 'reconnect=', 'update=', 'songs=', 'repeat=', 'lastfm=', 'album', 'logfile', 'daemonize', 'pidfile', 'verbose', 'help'])
		return opts
	except getopt.GetoptError, err:
		print str(err)
		usage()
		sys.exit(1)

def getoptions(): # {{{2

	options = []

	# Read user's configuration file?
	configfile = os.path.expanduser(CONFIG_FNAME)
	if os.path.exists(configfile):
		handle = open(configfile, 'r')
		options.extend(doargs(handle.read().split('\n')))
		handle.close()

	# Parse the command-line options.
	options.extend(doargs(sys.argv[1:]))

	# Define option defaults.
	hostname = '127.0.0.1'
	portnr = 6600
	passwd = ''
	songsleft = 3
	updatetime = 5
	reconnecttime = 60
	repeatfactor = 20
	albummode = False
	logfile = False
	daemonize = False
	verbosity = 0
	lastfmaccount = ''
	pidfile = False

	# Process command-line options.
	for option, argument in options:
		if option in ('-H', '--host'): hostname = argument
		elif option in ('-p', '--port'): portnr = int(argument)
		elif option in ('-P', '--pass'): passwd = argument
		elif option in ('-s', '--songs'): songsleft = int(argument)
		elif option in ('-u', '--update'): updatetime = int(argument)
		elif option in ('-r', '--reconnect'): reconnecttime = int(argument)
		elif option in ('-R', '--repeat'): repeatfactor = int(argument)
		elif option in ('-l', '--lastfm'): lastfmaccount = argument
		elif option in ('-A', '--album'): albummode = True
		elif option in ('-L', '--logfile'): logfile = argument
		elif option in ('-D', '--daemonize'): daemonize = True
		elif option in ('-F', '--pidfile'): pidfile = argument
		elif option in ('-v', '--verbose'): verbosity += 1
		elif option in ('-h', '--help'):
			usage()
			sys.exit(0)
		else:
			print "Unhandled option `%s'" % (option)
			usage()
			sys.exit(1)

	options = {'hostname': hostname, \
						 'portnr': portnr, \
						 'passwd': passwd, \
						 'songsleft': songsleft, \
						 'updatetime': updatetime, \
						 'reconnecttime': reconnecttime, \
						 'repeatfactor': repeatfactor, \
						 'lastfmaccount': lastfmaccount, \
						 'albummode': albummode, \
						 'logfile': logfile, \
						 'daemonize': daemonize, \
						 'pidfile': pidfile, \
						 'verbosity': verbosity}

	return options

def usage(): # {{{2
	print 'Usage: %s [OPTION]...' % (os.path.split(sys.argv[0])[1])
	print """
  -H, --host=HOSTNAME          host name of Music Player Daemon (localhost)
  -p, --port=PORTNR            port number on which MPD is listening (6600)
  -P, --pass=PASSWORD          password for connecting with MPD (none)
  -u, --update=SECONDS         seconds between updates to the playlist (5)
  -r, --reconnect=SECONDS      seconds before client tries to reconnect (60)
  -R, --repeat=COUNT           number of last played tracks not to repeat (20)
  -s, --songs=COUNT            number of tracks before end of playlist to start
                               adding songs (3)
  -A, --album                  add whole albums instead of just one track.
  -L, --logfile=LOGFILE        Copy script output to file.
  -D, --daemonize              Detatch from consolle. (do not detatch)
  -F, --pidfile=FILENAME       process identifier file to use (none)
  -l, --lastfm=USERNAME        play tracks loved by user on Last.fm more
                               frequently and don't play banned tracks
  -h, --help                   show this help
"""

class LibraryIndex: # {{{1

	def __init__(self, mpdclient): # {{{2
		self.__tracks_by_artists = {}
		self.__tracks_in_genres = {}
		self.__albums_by_artists  = {}
		self.__tracks_in_albums = {}
		for track in mpdclient.listallinfo():
			self.__addtoindex('artist', track, self.__tracks_by_artists)
			self.__addtoindex('genre', track, self.__tracks_in_genres)
			if track.get('artist', '') != '' and track.get('album', '') != '':
				artistkey = simplifyname(track['artist'])
				if not self.__albums_by_artists.has_key(artistkey):
					self.__albums_by_artists[artistkey] = []
				if track['album'] not in self.__albums_by_artists[artistkey]:
					self.__albums_by_artists[artistkey].append(track['album'])
				albumkey = createkey(track['artist'], track['album'])
				if not self.__tracks_in_albums.has_key(albumkey):
					self.__tracks_in_albums[albumkey] = []
				self.__tracks_in_albums[albumkey].append(track)

	def __addtoindex(self, field, track, index): # {{{2
		if field in track:
			values = track[field]
			# track['genre'] can be a list of genres..
			if type(values) != type([]): values = [values]
			# and it may contain duplicates?! :\
			for value in unique(values):
				key = simplifyname(value)
				if key != '':
					if not index.has_key(key):
						index[key] = []
					index[key].append(track)
	
	def findtracksbyartist(self, artistname): # {{{2
		artistkey = simplifyname(artistname)
		return self.__tracks_by_artists.get(artistkey, [])

	def findtracksingenre(self, genrename): # {{{2
		genrekey = simplifyname(genrename)
		return self.__tracks_in_genres.get(genrekey, [])

	def findalbumsbyartist(self, artistname): # {{{2
		artistkey = simplifyname(artistname)
		return self.__albums_by_artists.get(artistkey, [])

	def findtracksinalbum(self, artistname, albumname): # {{{2
		albumkey = createkey(artistname, albumname)
		tracks = self.__tracks_in_albums.get(albumkey, [])
		tracks.sort(self.__sortalbumtracks)
		return tracks

	def __sortalbumtracks(self, x, y):
		return cmp(self.__gettracknr(x), self.__gettracknr(y))

	def __gettracknr(self, track):
		if track.get('track', '') != '':
			match = re.match('^\d+', track['track'])
			return int(match.group())
		return 0

# }}}1

if __name__ == '__main__':
	try:
		options = getoptions()
		if options['daemonize']:
			import daemon
			with daemon.DaemonContext():
				main(options)
		else:
			main(options)
	except SystemExit:
		if not not options['pidfile']:
			os.remove(options['pidfile'])
		sys.exit(0)	
