#!/usr/bin/env python

#Import with statement from __future__ to support python 2.5
from __future__ import with_statement
import getopt
import htmlentitydefs
import mpd
import os
import random
import re
import socket
import sys
import time
import urllib
import traceback

CONFIG_FNAME = '~/.mpd-myfm'


def main(options):

	if not not options['pidfile']:
		open(options['pidfile'],'w').write(str(os.getpid()))

	client = mpd.MPDClient()
	if not connect(client, options['hostname'], options['portnr'], options['passwd']):
		print "Failed to connect to MPD server at `%s' on port `%i'" % (options['hostname'], options['portnr'])
		usage()
		sys.exit(1)
	else:
<<<<<<< HEAD:mpd-myfm
		if options['verbosity'] >= 1:
			print "Building the index of mpd's library"
		# Create an index from the user's library.
		index = LibraryIndex(client)
		# Get the user's loved & banned tracks from Last.fm?
		lovedtracks = []
		lovedartists = []
		bannedtracks = []
		if options['lastfmaccount'] != '':
<<<<<<< HEAD:mpd-myfm
			if options['verbosity'] >= 1:
				print "Scraping last.fm for user's loved and banned tracks"
			for [artist, title] in lastfm.get_loved_tracks(options['lastfmaccount']):
				lovedtracks.append(createkey(artist, title))
				if artist != 'Various Artists' and not artist in lovedartists:
					lovedartists.append(createkey(artist))
			for [artist, title] in lastfm.get_banned_tracks(options['lastfmaccount']):
				bannedtracks.append(createkey(artist, title))
<<<<<<< HEAD:mpd-myfm
		if options['verbosity'] >= 1:
			print "Done... Now starting main program loop."
		while 1:
			try:
				if clientenabled(client.status(), options['songsleft'], options['verbosity']):
					lasttrack = client.playlistinfo()[-1]
					similarartists_complex = [[a['similarity'], a['name']] for a in lastfm.get_similar_artists(lasttrack['artist'])]
					similarartists = []
					for artist in similarartists_complex:
						similarartists.append([artist[0], simplifyname(artist[1])])
					similarartists = demoteplayedartists(client, options['repeatfactor'], similarartists)
					if not options['albummode'] or not addalbum(client, index, similarartists, options['verbosity']):
						addtrack(client, index, lasttrack, similarartists, options['repeatfactor'], lovedtracks, lovedartists, bannedtracks, options['verbosity'])
				# Sleep for a while before trying to update again.
				sleep(options['updatetime'], options['verbosity'])
			except (socket.error, mpd.ConnectionError), msgconerrer:
				# Let the user know what's going on.
				print 'Lost connection? (%s)' % msgconerrer
				# Try to close the connection in case it's still open.
				try: client.disconnect()
				except: pass
				# Sleep for a while before trying to reconnect.
				sleep(reconnecttime, options['verbosity'])
				# Loop until we're connected to MPD again.
				while not connect(client, options['hostname'], options['portnr'], options['passwd']): pass
			except KeyboardInterrupt:
				# Disconnect and close client when interrupted.
				client.disconnect()
				if not not options['pidfile']:
					os.remove(options['pidfile'])
				break

def addtrack(client, index, lasttrack, similarartists, repeatfactor, lovedtracks, lovedartists, bannedtracks, verbosity): # {{{1
	similartracks = findsimilartracks(index, similarartists)
	similartracks = filterduplicates(client, repeatfactor, similartracks)
	removebannedtracks(bannedtracks, similartracks, verbosity)
	# TODO Make treshold configurable?
	if len(similartracks) <= 3 and lasttrack.get('genre', '') != '':
		print "Adding track based on same genre `%s'." % (lasttrack['genre'])
		for track in index.findtracksingenre(lasttrack['genre']):
			similartracks.append([1, track])
		similartracks = filterduplicates(client, repeatfactor, similartracks)
		removebannedtracks(bannedtracks, similartracks, verbosity)
	if len(similartracks) >= 1:
		marklovedtracks(similartracks, lovedtracks, lovedartists, verbosity)
		tracktoadd = weightedrandomchoice(similartracks)
		client.add(tracktoadd['file'])
		if verbosity >= 1:
			print 'Added', tracktoadd['file'], 'to playlist.'
	elif verbosity >= 1:
		print 'Failed to find similar track based on artist nor genre!'

def addalbum(client, index, similarartists, verbosity): # {{{1
	similaralbums = findsimilaralbums(index, similarartists)
	if len(similaralbums) <= 1:
		if verbosity >= 1:
			print 'Could not find any albums from similar artists, trying one lose track now.'
			print 'I will try an album again after that.'
		return False
	albumtoadd = weightedrandomchoice(similaralbums)
	trackstoload = index.findtracksinalbum(albumtoadd[0], albumtoadd[1])
	print "Adding %i tracks in album `%s' by artist `%s'" % ( \
			len(trackstoload), albumtoadd[1], albumtoadd[0])
	for track in trackstoload:
		client.add(track['file'])
	return True

def findsimilaralbums(index, similarartists): # {{{1
	"""
	Return a list of albums in the Music Player Daemon library from any of the
	given artists. The numeric similarity associated with each artist is copied
	to all albums by that artist.
	"""
	albums = []
	for [similarity, artistname] in similarartists:
		for albumname in index.findalbumsbyartist(artistname):
				albums.append([similarity, [artistname, albumname]])
	return albums

def filterduplicates(client, repeatfactor, tracks): # {{{1
	"""
	Make sure a track is never repeated before a configurable number of other
	tracks (by default 20) has been played. The number of tracks can be set
	using the -s or --songs command-line argument.
	"""
	trackstofilter = client.playlist()
	if len(trackstofilter) < repeatfactor:
		repeatfactor = len(trackstofilter)
	trackstofilter = trackstofilter[-repeatfactor : -1]
	return [t for t in tracks if not t[1]['file'] in trackstofilter]

def demoteplayedartists(client, repeatfactor, similarartists): # {{{1
	"""
	Make it less likely that a song from an artist who is already in the last
	'repeatfactor' songs. We do not ban them because that would	make it very 
	hard to find similar songs after a wile.
	"""
	trackstofilter = client.playlistinfo()
	if len(trackstofilter) < repeatfactor:
		repeatfactor = len(trackstofilter)
	trackstofilter = trackstofilter[-repeatfactor : -1]
	artiststofilter = []
	for track in trackstofilter:
		artiststofilter.append(simplifyname(track['artist'].decode('utf-8')))
	demotedlist = []
	for artist in similarartists:
		if artist[1] in artiststofilter:
			artist[0] = artist[0] / 5
			demotedlist.append(artist)
		else:
			demotedlist.append(artist)
	return demotedlist

def clientenabled(status, songsleft, verbosity): # {{{1
	if int(status['playlistlength']) == 0:
		if verbosity >= 3: print "Doing nothing because play list is empty."
		return False
	if int(status['random']) != 0:
		if verbosity >= 3: print "Doing nothing because random is enabled."
		return False
	if int(status['repeat']) != 0:
		if verbosity >= 3: print "Doing nothing because repeat is enabled."
		return False
	if status.has_key('song') and int(status['playlistlength']) > (int(status['song']) + songsleft) \
			or not status.has_key('song') and int(status['playlistlength']) >= songsleft:
		if verbosity >= 3: print "Doing nothing because the end of the playlist hasn't been reached."
		return False
	return True

def findsimilartracks(index, similarartists): # {{{1
	"""
	Return a list of tracks in the Music Player Daemon library from any of the
	given artists. The numeric similarity associated with each artist is copied
	to all tracks by that artist.
	"""
	tracks = []
	for [similarity, artistname] in similarartists:
		for track in index.findtracksbyartist(artistname):
			tracks.append([similarity, track])
	return tracks

def marklovedtracks(similartracks, lovedtracks, lovedartists, verbosity): # {{{1
	"""
	Go through the similar tracks and increase the weights of favorite tracks
	and artists.
	"""
	nlovedtracks = 0
	nlovedartists = 0
	for record in similartracks:
		similarity, track = record
		if track.get('artist', '') != '' and track.get('title', '') != '' and \
				createkey(track['artist'], track['title']) in lovedtracks:
			record[0] += 25
			nlovedtracks += 1
		elif track.get('artist', '') != '' and \
				createkey(track['artist']) in lovedartists:
			record[0] += 10
			nlovedartists += 1
	if verbosity >= 3:
		if nlovedtracks > 0: print 'Marked', nlovedtracks, 'loved tracks from Last.fm'
		if nlovedartists > 0: print 'Marked', nlovedartists, 'tracks by loved artists from Last.fm'

def removebannedtracks(bannedtracks, similartracks, verbosity): # {{{1
	"""
	Go through the similar tracks and remove all banned tracks.
	"""
	nbannedtracks = 0
	index = 0
	while index < len(similartracks):
		weight, track = similartracks[index]
		if track.get('artist', '') != '' and track.get('title', '') != '' and \
				createkey(track['artist'], track['title']) in bannedtracks:
			del similartracks[index]
			nbannedtracks += 1
		else:
			index += 1
	if verbosity >= 3 and nbannedtracks > 0:
		print 'Ignored', nbannedtracks, 'banned track(s) from Last.fm'


# Miscellaneous functions. {{{1

def createkey(*args): # {{{2
	"""
	Simplify a list of strings (one or more of artist name, album name, track
	title) into a single string using the simplifyname() function.
	"""
	return '-'.join(map(simplifyname, args))

def simplifyname(string): # {{{2
	"""
	Simplify artist names for fuzzy matching.
	"""
	global _cachednames
	if _cachednames.has_key(string):
		return _cachednames[string]
	else:
		result = string.lower()
		result = re.sub('^the\s+', '', result)
		result = re.sub(',\s+the$', '', result)
		result = re.sub('[^a-z0-9 -]', '', result)
		result = re.sub('\s+', ' ', result)
		_cachednames[string] = result
		return result
 
_cachednames = {}

def simplecompare(left, right): # {{{2
	"""
	Compare two strings using the simplifyname() function and return True when
	they are equal.
	"""
	return simplifyname(left) == simplifyname(right)

def weightedrandomchoice(items): # {{{2
	"""
	Pick a weighted random value from a list of lists, where each list contains
	a numeric weight followed by any type of associated value.
	"""
	total = 0
	for item in items:
		total += item[0]
	threshold = random.uniform(0.6, 1) * total 
	items.sort()
	for item in items:
		threshold -= item[0]
		if threshold <= 0:
			return item[1]

def sleep(seconds, verbosity): # {{{2
	if verbosity >= 2:
		print 'Sleeping for', seconds, 'seconds'
	time.sleep(seconds)

def unique(list): # {{{2
    result = []
    for item in list:
        if item not in result:
            result.append(item)
    return result

class logtee: # {{{2
	def __init__(self, *files):
		self.files=files
	def write(self, string):
		for file in self.files:
			file.write(string)

def createlog(options):
	if not not options['logfile']:
		#save original stdout
		stdout = sys.stdout
		logfile = open(options['logfile'],'a', 0)
		if not not options['daemonize']:
			#make all print statments go to logfile
			sys.stdout = logfile
		else:
			#make all print statments go to stdout and logfile
			sys.stdout = logtee(stdout, logfile)
	print 'Started mpd-myfm client'
	return logfile

def connect(client, hostname, portnr, passwd): # {{{2
	try:
		client.connect(host=hostname, port=portnr)
		if passwd != '': client.password(passwd)
		return True
	except socket.error:
		return False

def doargs(args): # {{{2
	try:
		opts, args = getopt.getopt(args, 'H:p:P:r:u:s:R:l:AL:DF:vh', \
				['host=', 'port=', 'pass=', 'reconnect=', 'update=', 'songs=', 'repeat=', 'lastfm=', 'album', 'logfile', 'daemonize', 'pidfile', 'verbose', 'help'])
		return opts
	except getopt.GetoptError, err:
		print str(err)
		usage()
		sys.exit(1)

def getoptions(): # {{{2

	options = []

	# Read user's configuration file?
	configfile = os.path.expanduser(CONFIG_FNAME)
	if os.path.exists(configfile):
		handle = open(configfile, 'r')
		options.extend(doargs(handle.read().split('\n')))
		handle.close()

	# Parse the command-line options.
	options.extend(doargs(sys.argv[1:]))

	# Define option defaults.
	hostname = '127.0.0.1'
	portnr = 6600
	passwd = ''
	songsleft = 3
	updatetime = 5
	reconnecttime = 60
	repeatfactor = 20
	albummode = False
	logfile = False
	daemonize = False
	verbosity = 0
	lastfmaccount = ''
	pidfile = False

	# Process command-line options.
	for option, argument in options:
		if option in ('-H', '--host'): hostname = argument
		elif option in ('-p', '--port'): portnr = int(argument)
		elif option in ('-P', '--pass'): passwd = argument
		elif option in ('-s', '--songs'): songsleft = int(argument)
		elif option in ('-u', '--update'): updatetime = int(argument)
		elif option in ('-r', '--reconnect'): reconnecttime = int(argument)
		elif option in ('-R', '--repeat'): repeatfactor = int(argument)
		elif option in ('-l', '--lastfm'): lastfmaccount = argument
		elif option in ('-A', '--album'): albummode = True
		elif option in ('-L', '--logfile'): logfile = argument
		elif option in ('-D', '--daemonize'): daemonize = True
		elif option in ('-F', '--pidfile'): pidfile = argument
		elif option in ('-v', '--verbose'): verbosity += 1
		elif option in ('-h', '--help'):
			usage()
			sys.exit(0)
		else:
			print "Unhandled option `%s'" % (option)
			usage()
			sys.exit(1)

	options = {'hostname': hostname, \
						 'portnr': portnr, \
						 'passwd': passwd, \
						 'songsleft': songsleft, \
						 'updatetime': updatetime, \
						 'reconnecttime': reconnecttime, \
						 'repeatfactor': repeatfactor, \
						 'lastfmaccount': lastfmaccount, \
						 'albummode': albummode, \
						 'logfile': logfile, \
						 'daemonize': daemonize, \
						 'pidfile': pidfile, \
						 'verbosity': verbosity}

	return options

def usage(): # {{{2
	print 'Usage: %s [OPTION]...' % (os.path.split(sys.argv[0])[1])
	print """
  -H, --host=HOSTNAME          host name of Music Player Daemon (localhost)
  -p, --port=PORTNR            port number on which MPD is listening (6600)
  -P, --pass=PASSWORD          password for connecting with MPD (none)
  -u, --update=SECONDS         seconds between updates to the playlist (5)
  -r, --reconnect=SECONDS      seconds before client tries to reconnect (60)
  -R, --repeat=COUNT           number of last played tracks not to repeat (20)
  -s, --songs=COUNT            number of tracks before end of playlist to start
                               adding songs (3)
  -A, --album                  add whole albums instead of just one track.
  -L, --logfile=LOGFILE        Copy script output to file.
  -D, --daemonize              Detatch from consolle. (do not detatch)
  -F, --pidfile=FILENAME       process identifier file to use (none)
  -l, --lastfm=USERNAME        play tracks loved by user on Last.fm more
                               frequently and don't play banned tracks
  -h, --help                   show this help
"""

class LibraryIndex: # {{{1

	def __init__(self, mpdclient): # {{{2
		self.__tracks_by_artists = {}
		self.__tracks_in_genres = {}
		self.__albums_by_artists  = {}
		self.__tracks_in_albums = {}
		for track in mpdclient.listallinfo():
			self.__addtoindex('artist', track, self.__tracks_by_artists)
			self.__addtoindex('genre', track, self.__tracks_in_genres)
			if track.get('artist', '') != '' and track.get('album', '') != '':
				artistkey = simplifyname(track['artist'])
				if not self.__albums_by_artists.has_key(artistkey):
					self.__albums_by_artists[artistkey] = []
				if track['album'] not in self.__albums_by_artists[artistkey]:
					self.__albums_by_artists[artistkey].append(track['album'])
				albumkey = createkey(track['artist'], track['album'])
				if not self.__tracks_in_albums.has_key(albumkey):
					self.__tracks_in_albums[albumkey] = []
				self.__tracks_in_albums[albumkey].append(track)

	def __addtoindex(self, field, track, index): # {{{2
		if field in track:
			values = track[field]
			# track['genre'] can be a list of genres..
			if type(values) != type([]): values = [values]
			# and it may contain duplicates?! :\
			for value in unique(values):
				key = simplifyname(value)
				if key != '':
					if not index.has_key(key):
						index[key] = []
					index[key].append(track)
	
	def findtracksbyartist(self, artistname): # {{{2
		artistkey = simplifyname(artistname)
		return self.__tracks_by_artists.get(artistkey, [])

	def findtracksingenre(self, genrename): # {{{2
		genrekey = simplifyname(genrename)
		return self.__tracks_in_genres.get(genrekey, [])

	def findalbumsbyartist(self, artistname): # {{{2
		artistkey = simplifyname(artistname)
		return self.__albums_by_artists.get(artistkey, [])

	def findtracksinalbum(self, artistname, albumname): # {{{2
		albumkey = createkey(artistname, albumname)
		tracks = self.__tracks_in_albums.get(albumkey, [])
		tracks.sort(self.__sortalbumtracks)
		return tracks

	def __sortalbumtracks(self, x, y):
		return cmp(self.__gettracknr(x), self.__gettracknr(y))

	def __gettracknr(self, track):
		if track.get('track', '') != '':
			match = re.match('^\d+', track['track'])
			return int(match.group())
		return 0

# }}}1

if __name__ == '__main__':
	options = getoptions()
	logfile = createlog(options)
	#import local modules, we do it here so that any errors get loged to the log file.
	try:
		import lastfm
		if options['daemonize']:
			import daemon
			with daemon.DaemonContext():
				main(options)
		else:
			main(options)
	except:
		print "An error has occured, the traceback can also be found in the logfile."
		traceback.print_exc(file=sys.stdout)
		sys.exit(1)
