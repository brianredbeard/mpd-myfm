#!/usr/bin/env python

import getopt
import mpd
import os
import random
import re
import socket
import sys
import time
import urllib

def main(): # {{{1

	# Parse the command-line options.
	try:
		options, arguments = getopt.getopt(sys.argv[1:], 'H:p:P:r:u:s:R:vh', \
				['host=', 'port=', 'pass=', 'reconnect=', 'update=', 'songs=', 'repeat=', 'verbose', 'help'])
	except getopt.GetoptError, err:
		print str(err)
		usage()
		sys.exit(1)

	# Define command-line option defaults.
	hostname = '127.0.0.1'
	portnr = 6600
	passwd = ''
	songsleft = 3
	updatetime = 5
	reconnecttime = 60
	repeatfactor = 20
	verbosity = 0

	# Process the command-line options.
	for option, argument in options:
		if option in ('-H', '--host'): hostname = argument
		elif option in ('-p', '--port'): portnr = int(argument)
		elif option in ('-P', '--pass'): passwd = argument
		elif option in ('-s', '--songs'): songsleft = int(argument)
		elif option in ('-u', '--update'): updatetime = int(argument)
		elif option in ('-r', '--reconnect'): reconnecttime = int(argument)
		elif option in ('-R', '--repeat'): repeatfactor = int(argument)
		elif option in ('-v', '--verbose'): verbosity += 1
		elif option in ('-h', '--help'):
			usage()
			sys.exit(0)
		else:
			print "Unhandled option `%s'" % (option)
			usage()
			sys.exit(1)
	
	client = mpd.MPDClient()
	artistsindb = {}
	genresindb = {}
	if not connect(client, hostname, portnr, passwd):
		print "Failed to connect to MPD server at `%s' on port `%i'" % (hostname, portnr)
		usage()
		sys.exit(1)
	else:
		while 1:
			try:
				# Create mappings between (artist->tracks) and (genre->tracks)?
				if artistsindb == {}:
					for track in client.listallinfo():
						if 'artist' in track:
							artist = simplifyname(track['artist'])
							if artist != '':
								if not artistsindb.has_key(artist):
									artistsindb[artist] = []
								artistsindb[artist].append(track['file'])
						if 'genre' in track:
							# track['genre'] can be a list of genres ..
							if type(track['genre']) == type(''): genres = [track['genre']]
							elif type(track['genre']) == type([]): genres = track['genre']
							else: genres = []
							# and may contain duplicates :\
							for genre in unique(genres):
								genre = simplifyname(genre)
								if genre != '':
									if not genresindb.has_key(genre): genresindb[genre] = []
									genresindb[genre].append(track['file'])
				if clientenabled(client.status(), songsleft, verbosity):
					lasttrack = client.playlistinfo()[-1]
					similarartists = getsimilarartists(lasttrack['artist'], verbosity)
					similartracks = findtracks(artistsindb, similarartists)
					similartracks = filterduplicates(client, repeatfactor, similartracks)
					if len(similartracks) <= 3: # TODO Make treshold configurable?
						if lasttrack.has_key('genre') and genresindb.has_key(lasttrack['genre']):
							for filename in genresindb[genre]:
								similartracks.append([0.2, filename])
							similartracks = filterduplicates(client, repeatfactor, similartracks)
					if len(similartracks) >= 1:
						tracktoadd = weightedrandomchoice(similartracks)
						client.add(tracktoadd)
							if verbosity >= 1:
								print 'Added', tracktoadd, 'to playlist.'
					elif verbosity >= 1:
						print 'Failed to find similar track based on artist nor genre!'
				# Sleep for a while before trying to update again.
				sleep(updatetime, verbosity)
			except (socket.error, mpd.ConnectionError), msgconerrer:
				# Let the user know what's going on.
				print 'Lost connection? (%s)' % msgconerrer
				# Try to close the connection in case it's still open.
				try: client.disconnect()
				except: pass
				# Sleep for a while before trying to reconnect.
				sleep(reconnecttime, verbosity)
				# Loop until we're connected to MPD again.
				while not connect(client, hostname, portnr, passwd): pass
			except KeyboardInterrupt:
				# Disconnect and close client when interrupted.
				client.disconnect()
				break

def sleep(seconds, verbosity): # {{{1
	if verbosity >= 2:
		print 'Sleeping for', seconds, 'seconds'
	time.sleep(seconds)

def weightedrandomchoice(items): # {{{1
	"""
	Pick a weighted random value from a list of lists, where each list contains
	a numeric weight followed by any type of associated value.
	"""
	total = 0
	for item in items:
		total += item[0]
	threshold = random.random() * total
	items.sort()
	for item in items:
		threshold -= item[0]
		if threshold <= 0:
			return item[1]

def unique(list): # {{{1
    result = []
    for item in list:
        if item not in result:
            result.append(item)
    return result

def filterduplicates(client, repeatfactor, tracks): # {{{1
	"""
	Make sure a track is never repeated before a configurable number of other
	tracks (by default 20) has been played. The number of tracks can be set
	using the -s or --songs command-line argument.
	"""
	trackstofilter = client.playlist()
	if len(trackstofilter) > repeatfactor:
		trackstofilter = trackstofilter[-repeatfactor]
	return [t for t in tracks if not t[1] in trackstofilter]

def simplifyname(artist): # {{{1
	"""
	Simplify artist names for fuzzy matching.
	"""
	artist = artist.lower()
	artist = re.sub('^the\s+', '', artist)
	artist = re.sub(',\s+the$', '', artist)
	artist = re.sub('[^a-z0-9 ]', '', artist)
	return re.sub('\s+', ' ', artist)

def clientenabled(status, songsleft, verbosity): # {{{1
	if int(status['playlistlength']) == 0:
		if verbosity >= 3: print "Doing nothing because play list is empty."
		return False
	if int(status['random']) != 0:
		if verbosity >= 3: print "Doing nothing because random is enabled."
		return False
	if int(status['repeat']) != 0:
		if verbosity >= 3: print "Doing nothing because repeat is enabled."
		return False
	if status.has_key('song') and int(status['playlistlength']) > (int(status['song']) + songsleft) \
			or not status.has_key('song') and int(status['playlistlength']) >= songsleft:
		if verbosity >= 3: print "Doing nothing because the end of the playlist hasn't been reached."
		return False
	return True

def findtracks(artistsindb, similarartists): # {{{1
	"""
	Return a list of tracks in the Music Player Daemon library from any of the
	given artists. The numeric similarity associated with each artist is copied
	to all tracks by that artist.
	"""
	tracks = []
	for [similarity, artistname] in similarartists:
		if artistsindb.has_key(artistname):
			for filename in artistsindb[artistname]:
				tracks.append([similarity, filename])
	return tracks

def getsimilarartists(inputartist, verbosity, limit=200): # {{{1
	"""
	Get a list of lists with similar artists from Last.fm. Each list contains a
	numeric similarity (between 0 and 100) followed by an artist name. The
	artists are sorted by decreasing similarity.
	"""
	address = 'http://ws.audioscrobbler.com/2.0/artist/%s/similar.txt?limit=%i'
	inputartistsimple = simplifyname(inputartist)
	handle = urllib.urlopen(address % (urllib.quote(inputartistsimple), limit))
	lines = handle.read().split("\n")
	handle.close()
	similarartists = []
	for record in [line.split(",") for line in lines]:
		if len(record) == 3:
			simplename = simplifyname(record[2])
			if simplename != '' and simplename != inputartistsimple:
				similarity = float(record[0])
				similarartists.append([similarity, simplename])
	if verbosity >= 2:
		print 'Fetched %i artists similar to %s from Last.fm' \
				% (len(similarartists), inputartist)
	similarartists.sort(None, None, True)
	return similarartists

def connect(client, hostname, portnr, passwd): # {{{1
	try:
		client.connect(host=hostname, port=portnr)
		if passwd != '': client.password(passwd)
		return True
	except socket.error:
		return False

def usage(): # {{{1
	scriptname = os.path.split(sys.argv[0])[1]
	print 'Usage: %s [OPTION]...' % (scriptname)
	print ''
	print '  -H, --host=HOSTNAME          host name of Music Player Daemon (localhost)'
	print '  -p, --port=PORTNR            port number on which MPD is listening (6600)'
	print '  -P, --pass=PASSWORD          password for connecting with MPD (empty)'
	print '  -r, --reconnect=SECONDS      seconds before client tries to reconnect (60)'
	print '  -u, --update=SECONDS         seconds between updates to the playlist (5)'
	print '  -s, --songs=COUNT            number of tracks before end of playlist to start adding songs (3)'
	print '  -h, --help                   show this help'

# }}}1

if __name__ == '__main__':
	main()
