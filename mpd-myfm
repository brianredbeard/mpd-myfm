#!/usr/bin/env python
# vim: set fileencoding=utf-8 :

import getopt
import htmlentitydefs
import mpd
import os
import random
import re
import socket
import sys
import time
import urllib

def main(): # {{{1

	# Parse the command-line options.
	try:
		options, arguments = getopt.getopt(sys.argv[1:], 'H:p:P:r:u:s:R:l:Avh', \
				['host=', 'port=', 'pass=', 'reconnect=', 'update=', 'songs=', 'repeat=', 'love=', 'album', 'verbose', 'help'])
	except getopt.GetoptError, err:
		print str(err)
		usage()
		sys.exit(1)

	# Define command-line option defaults.
	hostname = '127.0.0.1'
	portnr = 6600
	passwd = ''
	songsleft = 3
	updatetime = 5
	reconnecttime = 60
	repeatfactor = 20
	album = False
	verbosity = 0
	lastfmaccountforlovedtracks = ''

	# Process the command-line options.
	for option, argument in options:
		if option in ('-H', '--host'): hostname = argument
		elif option in ('-p', '--port'): portnr = int(argument)
		elif option in ('-P', '--pass'): passwd = argument
		elif option in ('-s', '--songs'): songsleft = int(argument)
		elif option in ('-u', '--update'): updatetime = int(argument)
		elif option in ('-r', '--reconnect'): reconnecttime = int(argument)
		elif option in ('-R', '--repeat'): repeatfactor = int(argument)
		elif option in ('-l', '--love'): lastfmaccountforlovedtracks = argument
		elif option in ('-A', '--album'): album = True
		elif option in ('-v', '--verbose'): verbosity += 1
		elif option in ('-h', '--help'):
			usage()
			sys.exit(0)
		else:
			print "Unhandled option `%s'" % (option)
			usage()
			sys.exit(1)

	global client
	client = mpd.MPDClient()
	if not connect(client, hostname, portnr, passwd):
		print "Failed to connect to MPD server at `%s' on port `%i'" % (hostname, portnr)
		usage()
		sys.exit(1)
	else:
		# Create an index from the user's library.
		index = LibraryIndex(client)
		# Get the user's loved tracks from Last.fm?
		lovedtracks = []
		if lastfmaccountforlovedtracks != '':
			lovedtracks = findlovedtracks(lastfmaccountforlovedtracks)
		while 1:
			try:
				if clientenabled(client.status(), songsleft, verbosity):
					lasttrack = client.playlistinfo()[-1]
					similarartists = getsimilarartists(lasttrack['artist'], verbosity)
					if album == True:
						addalbum(index, similarartists)
					else:
						addtrack(index, similarartists, lovedtracks)
				
				# Sleep for a while before trying to update again.
				sleep(updatetime, verbosity)
			except (socket.error, mpd.ConnectionError), msgconerrer:
				# Let the user know what's going on.
				print 'Lost connection? (%s)' % msgconerrer
				# Try to close the connection in case it's still open.
				try: client.disconnect()
				except: pass
				# Sleep for a while before trying to reconnect.
				sleep(reconnecttime, verbosity)
				# Loop until we're connected to MPD again.
				while not connect(client, hostname, portnr, passwd): pass
			except KeyboardInterrupt:
				# Disconnect and close client when interrupted.
				client.disconnect()
				break

def addtrack(index, similarartists, lovedtracks):
	global client
	similartracks = findsimilartracks(index, similarartists)
	similartracks = filterduplicates(client, repeatfactor, similartracks)
	if len(similartracks) <= 3: # TODO Make treshold configurable?
		if lasttrack.has_key('genre'):
			for track in index.findtracksingenre(lasttrack['genre']):
				similartracks.append([0.1, track])
			similartracks = filterduplicates(client, repeatfactor, similartracks)
	if len(similartracks) >= 1:
		# TODO Add more weight to loved tracks
		marklovedtracks(similartracks, lovedtracks, verbosity)
		tracktoadd = weightedrandomchoice(similartracks)
		client.add(tracktoadd['file'])
		if verbosity >= 1:
			print 'Added', tracktoadd['file'], 'to playlist.'
	elif verbosity >= 1:
		print 'Failed to find similar track based on artist nor genre!'


def addalbum(index, similarartists):
	global client
	similaralbums = findsimilaralbums(index, similarartists)
	if len(similaralbums) <= 1:
		if verbosity >= 1:
			print 'Could not find any albums from similar artists, trying one lose track now.'
			print 'I will try an album again after that.'
		addtrack(similarartists)
	albumtoadd = weightedrandomchoice(similaralbums)
	trackstoload = index.findtracksbyalbum(albumtoadd)
#	print trackstoload
	for track in trackstoload:
		print track['file']
		client.add(track['file'])


def findsimilaralbums(index, similarartists):
	"""
	Return a list of albums in the Music Player Daemon library from any of the
	given artists. The numeric similarity associated with each artist is copied
	to all albums by that artist.
	"""
	albums = []
	for [similarity, artistname] in similarartists:
		for album in index.findalbumsbyartist(artistname):
				albums.append([similarity, album])
	print 'findsimilaralbums:', albums
	return albums
	
def unique(list): # {{{2
    result = []
    for item in list:
        if item not in result:
            result.append(item)
    return result

def sleep(seconds, verbosity): # {{{2
	if verbosity >= 2:
		print 'Sleeping for', seconds, 'seconds'
	time.sleep(seconds)

def weightedrandomchoice(items): # {{{1
	"""
	Pick a weighted random value from a list of lists, where each list contains
	a numeric weight followed by any type of associated value.
	"""
	total = 0
	for item in items:
		total += item[0]
	threshold = random.random() * total
	items.sort()
	for item in items:
		threshold -= item[0]
		if threshold <= 0:
			return item[1]

def filterduplicates(client, repeatfactor, tracks): # {{{1
	"""
	Make sure a track is never repeated before a configurable number of other
	tracks (by default 20) has been played. The number of tracks can be set
	using the -s or --songs command-line argument.
	"""
	trackstofilter = client.playlist()
	if len(trackstofilter) > repeatfactor:
		trackstofilter = trackstofilter[-repeatfactor]
	return [t for t in tracks if not t[1]['file'] in trackstofilter]

def simplifyname(string): # {{{1
	"""
	Simplify artist names for fuzzy matching.
	"""
	global _cachednames
	if _cachednames.has_key(string):
		return _cachednames[string]
	else:
		result = string.lower()
		result = re.sub('^the\s+', '', result)
		result = re.sub(',\s+the$', '', result)
		result = re.sub('[^a-z0-9 -]', '', result)
		result = re.sub('\s+', ' ', result)
		_cachednames[string] = result
		return result

_cachednames = {}

def simplecompare(left, right): # {{{1
	return simplifyname(left) == simplifyname(right)

def clientenabled(status, songsleft, verbosity): # {{{1
	if int(status['playlistlength']) == 0:
		if verbosity >= 3: print "Doing nothing because play list is empty."
		return False
	if int(status['random']) != 0:
		if verbosity >= 3: print "Doing nothing because random is enabled."
		return False
	if int(status['repeat']) != 0:
		if verbosity >= 3: print "Doing nothing because repeat is enabled."
		return False
	if status.has_key('song') and int(status['playlistlength']) > (int(status['song']) + songsleft) \
			or not status.has_key('song') and int(status['playlistlength']) >= songsleft:
		if verbosity >= 3: print "Doing nothing because the end of the playlist hasn't been reached."
		return False
	return True

def findsimilartracks(index, similarartists): # {{{1
	"""
	Return a list of tracks in the Music Player Daemon library from any of the
	given artists. The numeric similarity associated with each artist is copied
	to all tracks by that artist.
	"""
	tracks = []
	for [similarity, artistname] in similarartists:
		for track in index.findtracksbyartist(artistname):
			tracks.append([similarity, track])
	return tracks

def getsimilarartists(inputartist, verbosity, limit=200): # {{{1
	"""
	Find artists similar to the given artist on Last.fm. The result is a list
	of lists, where each list contains a numeric similarity between 0 and 100
	where 100 is most similar, followed by an artist name. The artists are
	sorted by decreasing similarity.
	"""
	address = 'http://ws.audioscrobbler.com/2.0/artist/%s/similar.txt?limit=%i'
	handle = urllib.urlopen(address % (urllib.quote(simplifyname(inputartist)), limit))
	lines = handle.read().split("\n")
	handle.close()
	similarartists = []
	for record in [line.split(",") for line in lines]:
		if len(record) == 3:
			if not simplecompare(record[2], inputartist):
				similarity = float(record[0])
				similarartists.append([similarity, simplifyname(record[2])])
	if verbosity >= 2:
		print 'Fetched %i artists similar to %s from Last.fm' \
				% (len(similarartists), inputartist)
	similarartists.sort(None, None, True)
	return similarartists

def findlovedtracks(username): # {{{1
	"""
	Find the loved tracks of the given user on Last.fm. The result is a list of
	tuples, where each tuple contains an artist name and a track title.
	"""
	tracks = []
	address = 'http://www.last.fm/user/%s/library/loved?page=%i'
	regex = '<td[^>]*class="subjectCell"[^>]*>\s*<a[^>]*>(.*?)</a>\s+â€“\s+<a[^>]*>(.*?)</a>\s*</td>'
	pagenr = 1
	lastpage = None
	while pagenr == 1 and lastpage == None or pagenr <= lastpage:
		handle = urllib.urlopen(address % (username, pagenr))
		source = handle.read()
		handle.close()
		for (artist, track) in re.findall(regex, source, re.IGNORECASE):
			artist = htmlentitydecode(artist)
			track = htmlentitydecode(track)
			tracks.append((artist, track))
		if pagenr == 1 and lastpage == None:
			match = re.search('<a\s.*?class="lastpage">(\d+)</a>', source, re.IGNORECASE)
			lastpage = match and int(match.group(1)) or 1
		pagenr += 1
	return tracks

def marklovedtracks(similartracks, lovedtracks, verbosity): # {{{1
	"""
	Go through the similar tracks and increase the weights of favorite tracks
	and artists.
	"""
	# XXX There's a bug in here but I'm not quite sure how to solve it yet :\
	nlovedartists = 0
	nlovedtracks = 0
	for [artist, title] in lovedtracks:
		for record in similartracks:
			if record[1].has_key('artist') and simplecompare(artist, record[1]['artist']):
				if record[1].has_key('title') and simplecompare(title, record[1]['title']):
					record[0] += 25
					nlovedtracks += 1
				else:
					record[0] += 10
					nlovedartists += 1
	if verbosity >= 3:
		if nlovedtracks > 0: print 'Marked', nlovedtracks, 'loved tracks from Last.fm'
		if nlovedartists > 0: print 'Marked', nlovedartists, 'loved artists from Last.fm'

def htmlentitydecode(string): # {{{2
	regex = re.compile("&(#?)(\d{1,5}|\w{1,8});")
	return regex.subn(htmlentitydecode_helper, string)[0]

def htmlentitydecode_helper(match): # {{{3
	ent = match.group(2)
	if match.group(1) == "#":
		return unichr(int(ent))
	else:
		cp = htmlentitydefs.name2codepoint.get(ent)
		return cp and unichr(cp) or match.group()

def connect(client, hostname, portnr, passwd): # {{{1
	try:
		client.connect(host=hostname, port=portnr)
		if passwd != '': client.password(passwd)
		return True
	except socket.error:
		return False

def usage(): # {{{1
	scriptname = os.path.split(sys.argv[0])[1]
	print 'Usage: %s [OPTION]...' % (scriptname)
	print ''
	print '  -H, --host=HOSTNAME          host name of Music Player Daemon (localhost)'
	print '  -p, --port=PORTNR            port number on which MPD is listening (6600)'
	print '  -P, --pass=PASSWORD          password for connecting with MPD (empty)'
	print '  -u, --update=SECONDS         seconds between updates to the playlist (5)'
	print '  -r, --reconnect=SECONDS      seconds before client tries to reconnect (60)'
	print '  -R, --repeat=COUNT           number of last played tracks not to repeat (20)'
	print '  -s, --songs=COUNT            number of tracks before end of playlist to start adding songs (3)'
	print '  -A, --album                  Add whole albums instead of just one track.'
	print '  -l, --love=USERNAME          play tracks loved by user on Last.fm more frequently'
	print '  -h, --help                   show this help'

class LibraryIndex: # {{{1

	def __init__(self, mpdclient): # {{{2
		self.__artists = {}
		self.__genres = {}
		self.__albumtracks = {}
		self.__albums = {}
		self.__database = mpdclient.listallinfo()
		for track in self.__database:
			self.__addtoindex('artist', track, self.__artists)
			self.__addtoindex('genre', track, self.__genres)
			self.__addtoindex('album', track, self.__albumtracks)
		for track in self.__database:
			if track.has_key('album'):
				value = track['album']
				key = simplifyname(track['artist'])
				if not self.__albums.has_key(key):
					self.__albums[key] = []
				self.__albums[key].append(track['album'])
		self.__database = None

	def __addtoindex(self, field, track, index,): # {{{2
		if field in track:
			values = track[field]
			# track['genre'] can be a list of genres..
			if type(values) != type([]): values = [values]
			# and it may contain duplicates?! :\
			for value in unique(values):
				key = simplifyname(value)
				if key != '':
					if not index.has_key(key):
						index[key] = []
					index[key].append(track)

	def findtracksbyartist(self, artistname): # {{{2
		key = simplifyname(artistname)
		if self.__artists.has_key(key):
			return self.__artists[key]
		return []

	def findtracksingenre(self, genrename): # {{{2
		simplename = simplifyname(genrename)
		if self.__genres.has_key(simplename):
			return self.__genres[simplename]
		return []

	def findalbumsbyartist(self, artistname):
		key = simplifyname(artistname)
		if self.__albums.has_key(key):
			return self.__albums[key]
		return []

	def findtracksbyalbum(self, albumname): # {{{2
		simplename = simplifyname(albumname)
		if self.__albumtracks.has_key(simplename):
			return self.__albumtracks[simplename]
		return []
		# Find all the tracks of an album.
		pass 

# }}}1

if __name__ == '__main__':
	main()
